"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/database/index.ts":
/*!***********************************!*\
  !*** ./src/lib/database/index.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   database: () => (/* binding */ database)\n/* harmony export */ });\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/idb/build/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\n\nclass DatabaseManager {\n    async init() {\n        if (this.db) return;\n        this.db = await (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)(this.DB_NAME, this.DB_VERSION, {\n            upgrade (db) {\n                // Create spaces store\n                const spacesStore = db.createObjectStore('spaces', {\n                    keyPath: 'id'\n                });\n                spacesStore.createIndex('by-type', 'type');\n                spacesStore.createIndex('by-updated', 'updatedAt');\n                spacesStore.createIndex('by-created', 'createdAt');\n                // Create samples store\n                const samplesStore = db.createObjectStore('samples', {\n                    keyPath: 'id'\n                });\n                samplesStore.createIndex('by-space', 'spaceId');\n                samplesStore.createIndex('by-recorded', 'recordedAt');\n                samplesStore.createIndex('by-quality', 'signalQuality');\n                samplesStore.createIndex('by-type', 'soundType');\n            }\n        });\n    }\n    ensureDB() {\n        if (!this.db) {\n            throw new Error('Database not initialized. Call init() first.');\n        }\n        return this.db;\n    }\n    // Space operations\n    async createSpace(data) {\n        const db = this.ensureDB();\n        const now = new Date();\n        const space = {\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            name: data.name,\n            description: data.description,\n            type: data.type,\n            createdAt: now,\n            updatedAt: now,\n            sampleIds: [],\n            metadata: data.metadata || {},\n            environmentalConditions: data.environmentalConditions || {},\n            analyzedFrequencies: []\n        };\n        await db.add('spaces', space);\n        return space;\n    }\n    async getSpace(id) {\n        const db = this.ensureDB();\n        return await db.get('spaces', id);\n    }\n    async getAllSpaces() {\n        const db = this.ensureDB();\n        return await db.getAllFromIndex('spaces', 'by-updated');\n    }\n    async updateSpace(id, updates) {\n        const db = this.ensureDB();\n        const existing = await db.get('spaces', id);\n        if (!existing) {\n            throw new Error(\"Space with id \".concat(id, \" not found\"));\n        }\n        const updated = {\n            ...existing,\n            ...updates,\n            id: existing.id,\n            updatedAt: new Date()\n        };\n        await db.put('spaces', updated);\n        return updated;\n    }\n    async deleteSpace(id) {\n        const db = this.ensureDB();\n        try {\n            // Start a transaction that includes both stores\n            const tx = db.transaction([\n                'spaces',\n                'samples'\n            ], 'readwrite');\n            const spacesStore = tx.objectStore('spaces');\n            const samplesStore = tx.objectStore('samples');\n            // Get all samples for this space\n            const samplesIndex = samplesStore.index('by-space');\n            const samples = await samplesIndex.getAll(id);\n            // Delete all samples for this space\n            for (const sample of samples){\n                await samplesStore.delete(sample.id);\n            }\n            // Delete the space\n            await spacesStore.delete(id);\n            // Wait for transaction to complete\n            await tx.done;\n            console.log(\"Successfully deleted space \".concat(id, \" and \").concat(samples.length, \" associated samples\"));\n        } catch (error) {\n            console.error('Error deleting space:', error);\n            throw new Error(\"Failed to delete space: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getSpaceCount() {\n        const db = this.ensureDB();\n        return await db.count('spaces');\n    }\n    // Sample operations\n    async createSample(data) {\n        const db = this.ensureDB();\n        const now = new Date();\n        const sample = {\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            spaceId: data.spaceId,\n            soundType: data.soundType,\n            audioFilePath: data.audioFilePath,\n            recordedAt: now,\n            duration: data.duration,\n            ambientNoiseLevel: data.ambientNoiseLevel || 0,\n            peaks: data.peaks || [],\n            spectralData: data.spectralData || {},\n            signalQuality: data.signalQuality || 'good',\n            sampleRate: data.sampleRate || 48000,\n            recordingSettings: data.recordingSettings || {}\n        };\n        await db.add('samples', sample);\n        // Update space's sample IDs\n        const space = await this.getSpace(data.spaceId);\n        if (space) {\n            await this.updateSpace(data.spaceId, {\n                sampleIds: [\n                    ...space.sampleIds,\n                    sample.id\n                ]\n            });\n        }\n        return sample;\n    }\n    async getSample(id) {\n        const db = this.ensureDB();\n        return await db.get('samples', id);\n    }\n    async getSamplesForSpace(spaceId) {\n        const db = this.ensureDB();\n        return await db.getAllFromIndex('samples', 'by-space', spaceId);\n    }\n    async getAllSamples() {\n        const db = this.ensureDB();\n        return await db.getAllFromIndex('samples', 'by-recorded');\n    }\n    async getRecentSamples() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        const db = this.ensureDB();\n        const allSamples = await db.getAllFromIndex('samples', 'by-recorded');\n        return allSamples.slice(-limit).reverse();\n    }\n    async updateSample(id, updates) {\n        const db = this.ensureDB();\n        const existing = await db.get('samples', id);\n        if (!existing) {\n            throw new Error(\"Sample with id \".concat(id, \" not found\"));\n        }\n        const updated = {\n            ...existing,\n            ...updates,\n            id: existing.id\n        };\n        await db.put('samples', updated);\n        return updated;\n    }\n    async deleteSample(id) {\n        const db = this.ensureDB();\n        const sample = await db.get('samples', id);\n        if (sample) {\n            // Remove from space's sample IDs\n            const space = await this.getSpace(sample.spaceId);\n            if (space) {\n                await this.updateSpace(sample.spaceId, {\n                    sampleIds: space.sampleIds.filter((sampleId)=>sampleId !== id)\n                });\n            }\n        }\n        await db.delete('samples', id);\n    }\n    async getSampleCount() {\n        const db = this.ensureDB();\n        return await db.count('samples');\n    }\n    // Utility methods\n    async clearAllData() {\n        const db = this.ensureDB();\n        await db.clear('spaces');\n        await db.clear('samples');\n    }\n    async exportData() {\n        const spaces = await this.getAllSpaces();\n        const samples = await this.getAllSamples();\n        return {\n            spaces,\n            samples\n        };\n    }\n    async importData(data) {\n        const db = this.ensureDB();\n        // Clear existing data\n        await this.clearAllData();\n        // Import spaces\n        for (const space of data.spaces){\n            await db.add('spaces', space);\n        }\n        // Import samples\n        for (const sample of data.samples){\n            await db.add('samples', sample);\n        }\n    }\n    constructor(){\n        this.db = null;\n        this.DB_NAME = 'resonance-detector';\n        this.DB_VERSION = 1;\n    }\n}\n// Singleton instance\nconst database = new DatabaseManager();\n// Initialize database on module load\nif (true) {\n    database.init().catch(console.error);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGF0YWJhc2UvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9EO0FBQ2pCO0FBeUJuQyxNQUFNRztJQUtKLE1BQU1DLE9BQXNCO1FBQzFCLElBQUksSUFBSSxDQUFDQyxFQUFFLEVBQUU7UUFFYixJQUFJLENBQUNBLEVBQUUsR0FBRyxNQUFNTCwyQ0FBTUEsQ0FBYyxJQUFJLENBQUNNLE9BQU8sRUFBRSxJQUFJLENBQUNDLFVBQVUsRUFBRTtZQUNqRUMsU0FBUUgsRUFBRTtnQkFDUixzQkFBc0I7Z0JBQ3RCLE1BQU1JLGNBQWNKLEdBQUdLLGlCQUFpQixDQUFDLFVBQVU7b0JBQ2pEQyxTQUFTO2dCQUNYO2dCQUNBRixZQUFZRyxXQUFXLENBQUMsV0FBVztnQkFDbkNILFlBQVlHLFdBQVcsQ0FBQyxjQUFjO2dCQUN0Q0gsWUFBWUcsV0FBVyxDQUFDLGNBQWM7Z0JBRXRDLHVCQUF1QjtnQkFDdkIsTUFBTUMsZUFBZVIsR0FBR0ssaUJBQWlCLENBQUMsV0FBVztvQkFDbkRDLFNBQVM7Z0JBQ1g7Z0JBQ0FFLGFBQWFELFdBQVcsQ0FBQyxZQUFZO2dCQUNyQ0MsYUFBYUQsV0FBVyxDQUFDLGVBQWU7Z0JBQ3hDQyxhQUFhRCxXQUFXLENBQUMsY0FBYztnQkFDdkNDLGFBQWFELFdBQVcsQ0FBQyxXQUFXO1lBQ3RDO1FBQ0Y7SUFDRjtJQUVRRSxXQUFzQztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDVCxFQUFFLEVBQUU7WUFDWixNQUFNLElBQUlVLE1BQU07UUFDbEI7UUFDQSxPQUFPLElBQUksQ0FBQ1YsRUFBRTtJQUNoQjtJQUVBLG1CQUFtQjtJQUNuQixNQUFNVyxZQUFZQyxJQUFxQixFQUFrQjtRQUN2RCxNQUFNWixLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUN4QixNQUFNSSxNQUFNLElBQUlDO1FBRWhCLE1BQU1DLFFBQWU7WUFDbkJDLElBQUluQixnREFBTUE7WUFDVm9CLE1BQU1MLEtBQUtLLElBQUk7WUFDZkMsYUFBYU4sS0FBS00sV0FBVztZQUM3QkMsTUFBTVAsS0FBS08sSUFBSTtZQUNmQyxXQUFXUDtZQUNYUSxXQUFXUjtZQUNYUyxXQUFXLEVBQUU7WUFDYkMsVUFBVVgsS0FBS1csUUFBUSxJQUFJLENBQUM7WUFDNUJDLHlCQUF5QlosS0FBS1ksdUJBQXVCLElBQUksQ0FBQztZQUMxREMscUJBQXFCLEVBQUU7UUFDekI7UUFFQSxNQUFNekIsR0FBRzBCLEdBQUcsQ0FBQyxVQUFVWDtRQUN2QixPQUFPQTtJQUNUO0lBRUEsTUFBTVksU0FBU1gsRUFBVSxFQUE4QjtRQUNyRCxNQUFNaEIsS0FBSyxJQUFJLENBQUNTLFFBQVE7UUFDeEIsT0FBTyxNQUFNVCxHQUFHNEIsR0FBRyxDQUFDLFVBQVVaO0lBQ2hDO0lBRUEsTUFBTWEsZUFBaUM7UUFDckMsTUFBTTdCLEtBQUssSUFBSSxDQUFDUyxRQUFRO1FBQ3hCLE9BQU8sTUFBTVQsR0FBRzhCLGVBQWUsQ0FBQyxVQUFVO0lBQzVDO0lBRUEsTUFBTUMsWUFBWWYsRUFBVSxFQUFFZ0IsT0FBdUIsRUFBa0I7UUFDckUsTUFBTWhDLEtBQUssSUFBSSxDQUFDUyxRQUFRO1FBQ3hCLE1BQU13QixXQUFXLE1BQU1qQyxHQUFHNEIsR0FBRyxDQUFDLFVBQVVaO1FBRXhDLElBQUksQ0FBQ2lCLFVBQVU7WUFDYixNQUFNLElBQUl2QixNQUFNLGlCQUFvQixPQUFITSxJQUFHO1FBQ3RDO1FBRUEsTUFBTWtCLFVBQWlCO1lBQ3JCLEdBQUdELFFBQVE7WUFDWCxHQUFHRCxPQUFPO1lBQ1ZoQixJQUFJaUIsU0FBU2pCLEVBQUU7WUFDZkssV0FBVyxJQUFJUDtRQUNqQjtRQUVBLE1BQU1kLEdBQUdtQyxHQUFHLENBQUMsVUFBVUQ7UUFDdkIsT0FBT0E7SUFDVDtJQUVBLE1BQU1FLFlBQVlwQixFQUFVLEVBQWlCO1FBQzNDLE1BQU1oQixLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUV4QixJQUFJO1lBQ0YsZ0RBQWdEO1lBQ2hELE1BQU00QixLQUFLckMsR0FBR3NDLFdBQVcsQ0FBQztnQkFBQztnQkFBVTthQUFVLEVBQUU7WUFDakQsTUFBTWxDLGNBQWNpQyxHQUFHRSxXQUFXLENBQUM7WUFDbkMsTUFBTS9CLGVBQWU2QixHQUFHRSxXQUFXLENBQUM7WUFFcEMsaUNBQWlDO1lBQ2pDLE1BQU1DLGVBQWVoQyxhQUFhaUMsS0FBSyxDQUFDO1lBQ3hDLE1BQU1DLFVBQVUsTUFBTUYsYUFBYUcsTUFBTSxDQUFDM0I7WUFFMUMsb0NBQW9DO1lBQ3BDLEtBQUssTUFBTTRCLFVBQVVGLFFBQVM7Z0JBQzVCLE1BQU1sQyxhQUFhcUMsTUFBTSxDQUFDRCxPQUFPNUIsRUFBRTtZQUNyQztZQUVBLG1CQUFtQjtZQUNuQixNQUFNWixZQUFZeUMsTUFBTSxDQUFDN0I7WUFFekIsbUNBQW1DO1lBQ25DLE1BQU1xQixHQUFHUyxJQUFJO1lBRWJDLFFBQVFDLEdBQUcsQ0FBQyw4QkFBd0NOLE9BQVYxQixJQUFHLFNBQXNCLE9BQWYwQixRQUFRTyxNQUFNLEVBQUM7UUFDckUsRUFBRSxPQUFPQyxPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDLE1BQU0sSUFBSXhDLE1BQU0sMkJBQW9GLE9BQXpEd0MsaUJBQWlCeEMsUUFBUXdDLE1BQU1DLE9BQU8sR0FBRztRQUN0RjtJQUNGO0lBRUEsTUFBTUMsZ0JBQWlDO1FBQ3JDLE1BQU1wRCxLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUN4QixPQUFPLE1BQU1ULEdBQUdxRCxLQUFLLENBQUM7SUFDeEI7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTUMsYUFBYTFDLElBQXNCLEVBQW1CO1FBQzFELE1BQU1aLEtBQUssSUFBSSxDQUFDUyxRQUFRO1FBQ3hCLE1BQU1JLE1BQU0sSUFBSUM7UUFFaEIsTUFBTThCLFNBQWlCO1lBQ3JCNUIsSUFBSW5CLGdEQUFNQTtZQUNWMEQsU0FBUzNDLEtBQUsyQyxPQUFPO1lBQ3JCQyxXQUFXNUMsS0FBSzRDLFNBQVM7WUFDekJDLGVBQWU3QyxLQUFLNkMsYUFBYTtZQUNqQ0MsWUFBWTdDO1lBQ1o4QyxVQUFVL0MsS0FBSytDLFFBQVE7WUFDdkJDLG1CQUFtQmhELEtBQUtnRCxpQkFBaUIsSUFBSTtZQUM3Q0MsT0FBT2pELEtBQUtpRCxLQUFLLElBQUksRUFBRTtZQUN2QkMsY0FBY2xELEtBQUtrRCxZQUFZLElBQUksQ0FBQztZQUNwQ0MsZUFBZW5ELEtBQUttRCxhQUFhLElBQUk7WUFDckNDLFlBQVlwRCxLQUFLb0QsVUFBVSxJQUFJO1lBQy9CQyxtQkFBbUJyRCxLQUFLcUQsaUJBQWlCLElBQUksQ0FBQztRQUNoRDtRQUVBLE1BQU1qRSxHQUFHMEIsR0FBRyxDQUFDLFdBQVdrQjtRQUV4Qiw0QkFBNEI7UUFDNUIsTUFBTTdCLFFBQVEsTUFBTSxJQUFJLENBQUNZLFFBQVEsQ0FBQ2YsS0FBSzJDLE9BQU87UUFDOUMsSUFBSXhDLE9BQU87WUFDVCxNQUFNLElBQUksQ0FBQ2dCLFdBQVcsQ0FBQ25CLEtBQUsyQyxPQUFPLEVBQUU7Z0JBQ25DakMsV0FBVzt1QkFBSVAsTUFBTU8sU0FBUztvQkFBRXNCLE9BQU81QixFQUFFO2lCQUFDO1lBQzVDO1FBQ0Y7UUFFQSxPQUFPNEI7SUFDVDtJQUVBLE1BQU1zQixVQUFVbEQsRUFBVSxFQUErQjtRQUN2RCxNQUFNaEIsS0FBSyxJQUFJLENBQUNTLFFBQVE7UUFDeEIsT0FBTyxNQUFNVCxHQUFHNEIsR0FBRyxDQUFDLFdBQVdaO0lBQ2pDO0lBRUEsTUFBTW1ELG1CQUFtQlosT0FBZSxFQUFxQjtRQUMzRCxNQUFNdkQsS0FBSyxJQUFJLENBQUNTLFFBQVE7UUFDeEIsT0FBTyxNQUFNVCxHQUFHOEIsZUFBZSxDQUFDLFdBQVcsWUFBWXlCO0lBQ3pEO0lBRUEsTUFBTWEsZ0JBQW1DO1FBQ3ZDLE1BQU1wRSxLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUN4QixPQUFPLE1BQU1ULEdBQUc4QixlQUFlLENBQUMsV0FBVztJQUM3QztJQUVBLE1BQU11QyxtQkFBdUQ7WUFBdENDLFFBQUFBLGlFQUFnQjtRQUNyQyxNQUFNdEUsS0FBSyxJQUFJLENBQUNTLFFBQVE7UUFDeEIsTUFBTThELGFBQWEsTUFBTXZFLEdBQUc4QixlQUFlLENBQUMsV0FBVztRQUN2RCxPQUFPeUMsV0FBV0MsS0FBSyxDQUFDLENBQUNGLE9BQU9HLE9BQU87SUFDekM7SUFFQSxNQUFNQyxhQUFhMUQsRUFBVSxFQUFFZ0IsT0FBd0IsRUFBbUI7UUFDeEUsTUFBTWhDLEtBQUssSUFBSSxDQUFDUyxRQUFRO1FBQ3hCLE1BQU13QixXQUFXLE1BQU1qQyxHQUFHNEIsR0FBRyxDQUFDLFdBQVdaO1FBRXpDLElBQUksQ0FBQ2lCLFVBQVU7WUFDYixNQUFNLElBQUl2QixNQUFNLGtCQUFxQixPQUFITSxJQUFHO1FBQ3ZDO1FBRUEsTUFBTWtCLFVBQWtCO1lBQ3RCLEdBQUdELFFBQVE7WUFDWCxHQUFHRCxPQUFPO1lBQ1ZoQixJQUFJaUIsU0FBU2pCLEVBQUU7UUFDakI7UUFFQSxNQUFNaEIsR0FBR21DLEdBQUcsQ0FBQyxXQUFXRDtRQUN4QixPQUFPQTtJQUNUO0lBRUEsTUFBTXlDLGFBQWEzRCxFQUFVLEVBQWlCO1FBQzVDLE1BQU1oQixLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUN4QixNQUFNbUMsU0FBUyxNQUFNNUMsR0FBRzRCLEdBQUcsQ0FBQyxXQUFXWjtRQUV2QyxJQUFJNEIsUUFBUTtZQUNWLGlDQUFpQztZQUNqQyxNQUFNN0IsUUFBUSxNQUFNLElBQUksQ0FBQ1ksUUFBUSxDQUFDaUIsT0FBT1csT0FBTztZQUNoRCxJQUFJeEMsT0FBTztnQkFDVCxNQUFNLElBQUksQ0FBQ2dCLFdBQVcsQ0FBQ2EsT0FBT1csT0FBTyxFQUFFO29CQUNyQ2pDLFdBQVdQLE1BQU1PLFNBQVMsQ0FBQ3NELE1BQU0sQ0FBQ0MsQ0FBQUEsV0FBWUEsYUFBYTdEO2dCQUM3RDtZQUNGO1FBQ0Y7UUFFQSxNQUFNaEIsR0FBRzZDLE1BQU0sQ0FBQyxXQUFXN0I7SUFDN0I7SUFFQSxNQUFNOEQsaUJBQWtDO1FBQ3RDLE1BQU05RSxLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUN4QixPQUFPLE1BQU1ULEdBQUdxRCxLQUFLLENBQUM7SUFDeEI7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTTBCLGVBQThCO1FBQ2xDLE1BQU0vRSxLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUN4QixNQUFNVCxHQUFHZ0YsS0FBSyxDQUFDO1FBQ2YsTUFBTWhGLEdBQUdnRixLQUFLLENBQUM7SUFDakI7SUFFQSxNQUFNQyxhQUE4RDtRQUNsRSxNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDckQsWUFBWTtRQUN0QyxNQUFNYSxVQUFVLE1BQU0sSUFBSSxDQUFDMEIsYUFBYTtRQUN4QyxPQUFPO1lBQUVjO1lBQVF4QztRQUFRO0lBQzNCO0lBRUEsTUFBTXlDLFdBQVd2RSxJQUE0QyxFQUFpQjtRQUM1RSxNQUFNWixLQUFLLElBQUksQ0FBQ1MsUUFBUTtRQUV4QixzQkFBc0I7UUFDdEIsTUFBTSxJQUFJLENBQUNzRSxZQUFZO1FBRXZCLGdCQUFnQjtRQUNoQixLQUFLLE1BQU1oRSxTQUFTSCxLQUFLc0UsTUFBTSxDQUFFO1lBQy9CLE1BQU1sRixHQUFHMEIsR0FBRyxDQUFDLFVBQVVYO1FBQ3pCO1FBRUEsaUJBQWlCO1FBQ2pCLEtBQUssTUFBTTZCLFVBQVVoQyxLQUFLOEIsT0FBTyxDQUFFO1lBQ2pDLE1BQU0xQyxHQUFHMEIsR0FBRyxDQUFDLFdBQVdrQjtRQUMxQjtJQUNGOzthQXJQUTVDLEtBQXVDO2FBQzlCQyxVQUFVO2FBQ1ZDLGFBQWE7O0FBb1BoQztBQUVBLHFCQUFxQjtBQUNkLE1BQU1rRixXQUFXLElBQUl0RixrQkFBaUI7QUFFN0MscUNBQXFDO0FBQ3JDLElBQUksSUFBNkIsRUFBRTtJQUNqQ3NGLFNBQVNyRixJQUFJLEdBQUdzRixLQUFLLENBQUN0QyxRQUFRRyxLQUFLO0FBQ3JDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L3NyYy9saWIvZGF0YWJhc2UvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3BlbkRCLCBEQlNjaGVtYSwgSURCUERhdGFiYXNlIH0gZnJvbSAnaWRiJ1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCdcbmltcG9ydCB7IFNwYWNlLCBTYW1wbGUsIENyZWF0ZVNwYWNlRGF0YSwgQ3JlYXRlU2FtcGxlRGF0YSB9IGZyb20gJ0AvbGliL3R5cGVzJ1xuXG5pbnRlcmZhY2UgUmVzb25hbmNlREIgZXh0ZW5kcyBEQlNjaGVtYSB7XG4gIHNwYWNlczoge1xuICAgIGtleTogc3RyaW5nXG4gICAgdmFsdWU6IFNwYWNlXG4gICAgaW5kZXhlczoge1xuICAgICAgJ2J5LXR5cGUnOiBzdHJpbmdcbiAgICAgICdieS11cGRhdGVkJzogRGF0ZVxuICAgICAgJ2J5LWNyZWF0ZWQnOiBEYXRlXG4gICAgfVxuICB9XG4gIHNhbXBsZXM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBTYW1wbGVcbiAgICBpbmRleGVzOiB7XG4gICAgICAnYnktc3BhY2UnOiBzdHJpbmdcbiAgICAgICdieS1yZWNvcmRlZCc6IERhdGVcbiAgICAgICdieS1xdWFsaXR5Jzogc3RyaW5nXG4gICAgICAnYnktdHlwZSc6IHN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBEYXRhYmFzZU1hbmFnZXIge1xuICBwcml2YXRlIGRiOiBJREJQRGF0YWJhc2U8UmVzb25hbmNlREI+IHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSByZWFkb25seSBEQl9OQU1FID0gJ3Jlc29uYW5jZS1kZXRlY3RvcidcbiAgcHJpdmF0ZSByZWFkb25seSBEQl9WRVJTSU9OID0gMVxuXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuZGIpIHJldHVyblxuXG4gICAgdGhpcy5kYiA9IGF3YWl0IG9wZW5EQjxSZXNvbmFuY2VEQj4odGhpcy5EQl9OQU1FLCB0aGlzLkRCX1ZFUlNJT04sIHtcbiAgICAgIHVwZ3JhZGUoZGIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHNwYWNlcyBzdG9yZVxuICAgICAgICBjb25zdCBzcGFjZXNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzcGFjZXMnLCB7XG4gICAgICAgICAga2V5UGF0aDogJ2lkJyxcbiAgICAgICAgfSlcbiAgICAgICAgc3BhY2VzU3RvcmUuY3JlYXRlSW5kZXgoJ2J5LXR5cGUnLCAndHlwZScpXG4gICAgICAgIHNwYWNlc1N0b3JlLmNyZWF0ZUluZGV4KCdieS11cGRhdGVkJywgJ3VwZGF0ZWRBdCcpXG4gICAgICAgIHNwYWNlc1N0b3JlLmNyZWF0ZUluZGV4KCdieS1jcmVhdGVkJywgJ2NyZWF0ZWRBdCcpXG5cbiAgICAgICAgLy8gQ3JlYXRlIHNhbXBsZXMgc3RvcmVcbiAgICAgICAgY29uc3Qgc2FtcGxlc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3NhbXBsZXMnLCB7XG4gICAgICAgICAga2V5UGF0aDogJ2lkJyxcbiAgICAgICAgfSlcbiAgICAgICAgc2FtcGxlc1N0b3JlLmNyZWF0ZUluZGV4KCdieS1zcGFjZScsICdzcGFjZUlkJylcbiAgICAgICAgc2FtcGxlc1N0b3JlLmNyZWF0ZUluZGV4KCdieS1yZWNvcmRlZCcsICdyZWNvcmRlZEF0JylcbiAgICAgICAgc2FtcGxlc1N0b3JlLmNyZWF0ZUluZGV4KCdieS1xdWFsaXR5JywgJ3NpZ25hbFF1YWxpdHknKVxuICAgICAgICBzYW1wbGVzU3RvcmUuY3JlYXRlSW5kZXgoJ2J5LXR5cGUnLCAnc291bmRUeXBlJylcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgZW5zdXJlREIoKTogSURCUERhdGFiYXNlPFJlc29uYW5jZURCPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZC4gQ2FsbCBpbml0KCkgZmlyc3QuJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGJcbiAgfVxuXG4gIC8vIFNwYWNlIG9wZXJhdGlvbnNcbiAgYXN5bmMgY3JlYXRlU3BhY2UoZGF0YTogQ3JlYXRlU3BhY2VEYXRhKTogUHJvbWlzZTxTcGFjZT4ge1xuICAgIGNvbnN0IGRiID0gdGhpcy5lbnN1cmVEQigpXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgIFxuICAgIGNvbnN0IHNwYWNlOiBTcGFjZSA9IHtcbiAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICB1cGRhdGVkQXQ6IG5vdyxcbiAgICAgIHNhbXBsZUlkczogW10sXG4gICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSB8fCB7fSxcbiAgICAgIGVudmlyb25tZW50YWxDb25kaXRpb25zOiBkYXRhLmVudmlyb25tZW50YWxDb25kaXRpb25zIHx8IHt9LFxuICAgICAgYW5hbHl6ZWRGcmVxdWVuY2llczogW10sXG4gICAgfVxuXG4gICAgYXdhaXQgZGIuYWRkKCdzcGFjZXMnLCBzcGFjZSlcbiAgICByZXR1cm4gc3BhY2VcbiAgfVxuXG4gIGFzeW5jIGdldFNwYWNlKGlkOiBzdHJpbmcpOiBQcm9taXNlPFNwYWNlIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmVuc3VyZURCKClcbiAgICByZXR1cm4gYXdhaXQgZGIuZ2V0KCdzcGFjZXMnLCBpZClcbiAgfVxuXG4gIGFzeW5jIGdldEFsbFNwYWNlcygpOiBQcm9taXNlPFNwYWNlW10+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIHJldHVybiBhd2FpdCBkYi5nZXRBbGxGcm9tSW5kZXgoJ3NwYWNlcycsICdieS11cGRhdGVkJylcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVNwYWNlKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8U3BhY2U+KTogUHJvbWlzZTxTcGFjZT4ge1xuICAgIGNvbnN0IGRiID0gdGhpcy5lbnN1cmVEQigpXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBkYi5nZXQoJ3NwYWNlcycsIGlkKVxuICAgIFxuICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3BhY2Ugd2l0aCBpZCAke2lkfSBub3QgZm91bmRgKVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWQ6IFNwYWNlID0ge1xuICAgICAgLi4uZXhpc3RpbmcsXG4gICAgICAuLi51cGRhdGVzLFxuICAgICAgaWQ6IGV4aXN0aW5nLmlkLCAvLyBFbnN1cmUgSUQgZG9lc24ndCBjaGFuZ2VcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9XG5cbiAgICBhd2FpdCBkYi5wdXQoJ3NwYWNlcycsIHVwZGF0ZWQpXG4gICAgcmV0dXJuIHVwZGF0ZWRcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNwYWNlKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTdGFydCBhIHRyYW5zYWN0aW9uIHRoYXQgaW5jbHVkZXMgYm90aCBzdG9yZXNcbiAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oWydzcGFjZXMnLCAnc2FtcGxlcyddLCAncmVhZHdyaXRlJylcbiAgICAgIGNvbnN0IHNwYWNlc1N0b3JlID0gdHgub2JqZWN0U3RvcmUoJ3NwYWNlcycpXG4gICAgICBjb25zdCBzYW1wbGVzU3RvcmUgPSB0eC5vYmplY3RTdG9yZSgnc2FtcGxlcycpXG4gICAgICBcbiAgICAgIC8vIEdldCBhbGwgc2FtcGxlcyBmb3IgdGhpcyBzcGFjZVxuICAgICAgY29uc3Qgc2FtcGxlc0luZGV4ID0gc2FtcGxlc1N0b3JlLmluZGV4KCdieS1zcGFjZScpXG4gICAgICBjb25zdCBzYW1wbGVzID0gYXdhaXQgc2FtcGxlc0luZGV4LmdldEFsbChpZClcbiAgICAgIFxuICAgICAgLy8gRGVsZXRlIGFsbCBzYW1wbGVzIGZvciB0aGlzIHNwYWNlXG4gICAgICBmb3IgKGNvbnN0IHNhbXBsZSBvZiBzYW1wbGVzKSB7XG4gICAgICAgIGF3YWl0IHNhbXBsZXNTdG9yZS5kZWxldGUoc2FtcGxlLmlkKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWxldGUgdGhlIHNwYWNlXG4gICAgICBhd2FpdCBzcGFjZXNTdG9yZS5kZWxldGUoaWQpXG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB0eC5kb25lXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZGVsZXRlZCBzcGFjZSAke2lkfSBhbmQgJHtzYW1wbGVzLmxlbmd0aH0gYXNzb2NpYXRlZCBzYW1wbGVzYClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgc3BhY2U6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgc3BhY2U6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTcGFjZUNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmVuc3VyZURCKClcbiAgICByZXR1cm4gYXdhaXQgZGIuY291bnQoJ3NwYWNlcycpXG4gIH1cblxuICAvLyBTYW1wbGUgb3BlcmF0aW9uc1xuICBhc3luYyBjcmVhdGVTYW1wbGUoZGF0YTogQ3JlYXRlU2FtcGxlRGF0YSk6IFByb21pc2U8U2FtcGxlPiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmVuc3VyZURCKClcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgXG4gICAgY29uc3Qgc2FtcGxlOiBTYW1wbGUgPSB7XG4gICAgICBpZDogdXVpZHY0KCksXG4gICAgICBzcGFjZUlkOiBkYXRhLnNwYWNlSWQsXG4gICAgICBzb3VuZFR5cGU6IGRhdGEuc291bmRUeXBlLFxuICAgICAgYXVkaW9GaWxlUGF0aDogZGF0YS5hdWRpb0ZpbGVQYXRoLFxuICAgICAgcmVjb3JkZWRBdDogbm93LFxuICAgICAgZHVyYXRpb246IGRhdGEuZHVyYXRpb24sXG4gICAgICBhbWJpZW50Tm9pc2VMZXZlbDogZGF0YS5hbWJpZW50Tm9pc2VMZXZlbCB8fCAwLFxuICAgICAgcGVha3M6IGRhdGEucGVha3MgfHwgW10sXG4gICAgICBzcGVjdHJhbERhdGE6IGRhdGEuc3BlY3RyYWxEYXRhIHx8IHt9LFxuICAgICAgc2lnbmFsUXVhbGl0eTogZGF0YS5zaWduYWxRdWFsaXR5IHx8ICdnb29kJyBhcyBhbnksXG4gICAgICBzYW1wbGVSYXRlOiBkYXRhLnNhbXBsZVJhdGUgfHwgNDgwMDAsXG4gICAgICByZWNvcmRpbmdTZXR0aW5nczogZGF0YS5yZWNvcmRpbmdTZXR0aW5ncyB8fCB7fSxcbiAgICB9XG5cbiAgICBhd2FpdCBkYi5hZGQoJ3NhbXBsZXMnLCBzYW1wbGUpXG4gICAgXG4gICAgLy8gVXBkYXRlIHNwYWNlJ3Mgc2FtcGxlIElEc1xuICAgIGNvbnN0IHNwYWNlID0gYXdhaXQgdGhpcy5nZXRTcGFjZShkYXRhLnNwYWNlSWQpXG4gICAgaWYgKHNwYWNlKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZVNwYWNlKGRhdGEuc3BhY2VJZCwge1xuICAgICAgICBzYW1wbGVJZHM6IFsuLi5zcGFjZS5zYW1wbGVJZHMsIHNhbXBsZS5pZF0sXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc2FtcGxlXG4gIH1cblxuICBhc3luYyBnZXRTYW1wbGUoaWQ6IHN0cmluZyk6IFByb21pc2U8U2FtcGxlIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmVuc3VyZURCKClcbiAgICByZXR1cm4gYXdhaXQgZGIuZ2V0KCdzYW1wbGVzJywgaWQpXG4gIH1cblxuICBhc3luYyBnZXRTYW1wbGVzRm9yU3BhY2Uoc3BhY2VJZDogc3RyaW5nKTogUHJvbWlzZTxTYW1wbGVbXT4ge1xuICAgIGNvbnN0IGRiID0gdGhpcy5lbnN1cmVEQigpXG4gICAgcmV0dXJuIGF3YWl0IGRiLmdldEFsbEZyb21JbmRleCgnc2FtcGxlcycsICdieS1zcGFjZScsIHNwYWNlSWQpXG4gIH1cblxuICBhc3luYyBnZXRBbGxTYW1wbGVzKCk6IFByb21pc2U8U2FtcGxlW10+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIHJldHVybiBhd2FpdCBkYi5nZXRBbGxGcm9tSW5kZXgoJ3NhbXBsZXMnLCAnYnktcmVjb3JkZWQnKVxuICB9XG5cbiAgYXN5bmMgZ2V0UmVjZW50U2FtcGxlcyhsaW1pdDogbnVtYmVyID0gNSk6IFByb21pc2U8U2FtcGxlW10+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIGNvbnN0IGFsbFNhbXBsZXMgPSBhd2FpdCBkYi5nZXRBbGxGcm9tSW5kZXgoJ3NhbXBsZXMnLCAnYnktcmVjb3JkZWQnKVxuICAgIHJldHVybiBhbGxTYW1wbGVzLnNsaWNlKC1saW1pdCkucmV2ZXJzZSgpXG4gIH1cblxuICBhc3luYyB1cGRhdGVTYW1wbGUoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxTYW1wbGU+KTogUHJvbWlzZTxTYW1wbGU+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgZGIuZ2V0KCdzYW1wbGVzJywgaWQpXG4gICAgXG4gICAgaWYgKCFleGlzdGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTYW1wbGUgd2l0aCBpZCAke2lkfSBub3QgZm91bmRgKVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWQ6IFNhbXBsZSA9IHtcbiAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIGlkOiBleGlzdGluZy5pZCwgLy8gRW5zdXJlIElEIGRvZXNuJ3QgY2hhbmdlXG4gICAgfVxuXG4gICAgYXdhaXQgZGIucHV0KCdzYW1wbGVzJywgdXBkYXRlZClcbiAgICByZXR1cm4gdXBkYXRlZFxuICB9XG5cbiAgYXN5bmMgZGVsZXRlU2FtcGxlKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIGNvbnN0IHNhbXBsZSA9IGF3YWl0IGRiLmdldCgnc2FtcGxlcycsIGlkKVxuICAgIFxuICAgIGlmIChzYW1wbGUpIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIHNwYWNlJ3Mgc2FtcGxlIElEc1xuICAgICAgY29uc3Qgc3BhY2UgPSBhd2FpdCB0aGlzLmdldFNwYWNlKHNhbXBsZS5zcGFjZUlkKVxuICAgICAgaWYgKHNwYWNlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlU3BhY2Uoc2FtcGxlLnNwYWNlSWQsIHtcbiAgICAgICAgICBzYW1wbGVJZHM6IHNwYWNlLnNhbXBsZUlkcy5maWx0ZXIoc2FtcGxlSWQgPT4gc2FtcGxlSWQgIT09IGlkKSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgYXdhaXQgZGIuZGVsZXRlKCdzYW1wbGVzJywgaWQpXG4gIH1cblxuICBhc3luYyBnZXRTYW1wbGVDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGRiID0gdGhpcy5lbnN1cmVEQigpXG4gICAgcmV0dXJuIGF3YWl0IGRiLmNvdW50KCdzYW1wbGVzJylcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBhc3luYyBjbGVhckFsbERhdGEoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmVuc3VyZURCKClcbiAgICBhd2FpdCBkYi5jbGVhcignc3BhY2VzJylcbiAgICBhd2FpdCBkYi5jbGVhcignc2FtcGxlcycpXG4gIH1cblxuICBhc3luYyBleHBvcnREYXRhKCk6IFByb21pc2U8eyBzcGFjZXM6IFNwYWNlW107IHNhbXBsZXM6IFNhbXBsZVtdIH0+IHtcbiAgICBjb25zdCBzcGFjZXMgPSBhd2FpdCB0aGlzLmdldEFsbFNwYWNlcygpXG4gICAgY29uc3Qgc2FtcGxlcyA9IGF3YWl0IHRoaXMuZ2V0QWxsU2FtcGxlcygpXG4gICAgcmV0dXJuIHsgc3BhY2VzLCBzYW1wbGVzIH1cbiAgfVxuXG4gIGFzeW5jIGltcG9ydERhdGEoZGF0YTogeyBzcGFjZXM6IFNwYWNlW107IHNhbXBsZXM6IFNhbXBsZVtdIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZW5zdXJlREIoKVxuICAgIFxuICAgIC8vIENsZWFyIGV4aXN0aW5nIGRhdGFcbiAgICBhd2FpdCB0aGlzLmNsZWFyQWxsRGF0YSgpXG4gICAgXG4gICAgLy8gSW1wb3J0IHNwYWNlc1xuICAgIGZvciAoY29uc3Qgc3BhY2Ugb2YgZGF0YS5zcGFjZXMpIHtcbiAgICAgIGF3YWl0IGRiLmFkZCgnc3BhY2VzJywgc3BhY2UpXG4gICAgfVxuICAgIFxuICAgIC8vIEltcG9ydCBzYW1wbGVzXG4gICAgZm9yIChjb25zdCBzYW1wbGUgb2YgZGF0YS5zYW1wbGVzKSB7XG4gICAgICBhd2FpdCBkYi5hZGQoJ3NhbXBsZXMnLCBzYW1wbGUpXG4gICAgfVxuICB9XG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGRhdGFiYXNlID0gbmV3IERhdGFiYXNlTWFuYWdlcigpXG5cbi8vIEluaXRpYWxpemUgZGF0YWJhc2Ugb24gbW9kdWxlIGxvYWRcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBkYXRhYmFzZS5pbml0KCkuY2F0Y2goY29uc29sZS5lcnJvcilcbn0iXSwibmFtZXMiOlsib3BlbkRCIiwidjQiLCJ1dWlkdjQiLCJEYXRhYmFzZU1hbmFnZXIiLCJpbml0IiwiZGIiLCJEQl9OQU1FIiwiREJfVkVSU0lPTiIsInVwZ3JhZGUiLCJzcGFjZXNTdG9yZSIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImNyZWF0ZUluZGV4Iiwic2FtcGxlc1N0b3JlIiwiZW5zdXJlREIiLCJFcnJvciIsImNyZWF0ZVNwYWNlIiwiZGF0YSIsIm5vdyIsIkRhdGUiLCJzcGFjZSIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwidHlwZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInNhbXBsZUlkcyIsIm1ldGFkYXRhIiwiZW52aXJvbm1lbnRhbENvbmRpdGlvbnMiLCJhbmFseXplZEZyZXF1ZW5jaWVzIiwiYWRkIiwiZ2V0U3BhY2UiLCJnZXQiLCJnZXRBbGxTcGFjZXMiLCJnZXRBbGxGcm9tSW5kZXgiLCJ1cGRhdGVTcGFjZSIsInVwZGF0ZXMiLCJleGlzdGluZyIsInVwZGF0ZWQiLCJwdXQiLCJkZWxldGVTcGFjZSIsInR4IiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsInNhbXBsZXNJbmRleCIsImluZGV4Iiwic2FtcGxlcyIsImdldEFsbCIsInNhbXBsZSIsImRlbGV0ZSIsImRvbmUiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0U3BhY2VDb3VudCIsImNvdW50IiwiY3JlYXRlU2FtcGxlIiwic3BhY2VJZCIsInNvdW5kVHlwZSIsImF1ZGlvRmlsZVBhdGgiLCJyZWNvcmRlZEF0IiwiZHVyYXRpb24iLCJhbWJpZW50Tm9pc2VMZXZlbCIsInBlYWtzIiwic3BlY3RyYWxEYXRhIiwic2lnbmFsUXVhbGl0eSIsInNhbXBsZVJhdGUiLCJyZWNvcmRpbmdTZXR0aW5ncyIsImdldFNhbXBsZSIsImdldFNhbXBsZXNGb3JTcGFjZSIsImdldEFsbFNhbXBsZXMiLCJnZXRSZWNlbnRTYW1wbGVzIiwibGltaXQiLCJhbGxTYW1wbGVzIiwic2xpY2UiLCJyZXZlcnNlIiwidXBkYXRlU2FtcGxlIiwiZGVsZXRlU2FtcGxlIiwiZmlsdGVyIiwic2FtcGxlSWQiLCJnZXRTYW1wbGVDb3VudCIsImNsZWFyQWxsRGF0YSIsImNsZWFyIiwiZXhwb3J0RGF0YSIsInNwYWNlcyIsImltcG9ydERhdGEiLCJkYXRhYmFzZSIsImNhdGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/database/index.ts\n"));

/***/ })

});